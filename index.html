<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Franky: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Franky
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">A High-Level Motion API for Franka</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Franky Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_runner_work_franky_franky_README"></a> </p><div align="center"> <img src="https://raw.githubusercontent.com/timschneider42/franky/master/doc/logo.svg?sanitize=true" alt="" style="pointer-events: none;" width="340" class="inline"/> <h3 align="center">High-Level Motion Library for the Franka Emika Robot </h3>
</div><div align="center"> </div> <p><a href="https://github.com/timschneider42/franky/actions"><img src="https://github.com/timschneider42/franky/workflows/CI/badge.svg" alt="CI" style="pointer-events: none;" class="inline"/> </a></p>
<p><a href="https://github.com/timschneider42/franky/actions"><img src="https://github.com/timschneider42/franky/workflows/Publish/badge.svg" alt="Publish" style="pointer-events: none;" class="inline"/> </a></p>
<p><a href="https://github.com/timschneider42/franky/issues"><img src="https://img.shields.io/github/issues/timschneider42/franky.svg" alt="Issues" style="pointer-events: none;" class="inline"/> </a></p>
<p><a href="https://github.com/timschneider42/franky/releases"><img src="https://img.shields.io/github/v/release/timschneider42/franky.svg?include_prereleases&amp;sort=semver" alt="Releases" style="pointer-events: none;" class="inline"/> </a></p>
<p><a href="https://github.com/timschneider42/franky/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-LGPL-green.svg" alt="LGPL" style="pointer-events: none;" class="inline"/> </a> </p>
<p>Franky is a high-level motion library (both C++ and Python) for the Franka Emika robot. It adds a Python wrapper around <a href="https://frankaemika.github.io/docs/libfranka.html">libfranka</a>, while replacing necessary real-time programming with higher-level motion commands. As franky focuses on making real-time trajectory generation easy, it allows the robot to react to unforeseen events.</p>
<h2>Differences to frankx</h2>
<p>Franky is a fork of <a href="https://github.com/pantor/frankx">frankx</a>, though both codebase and functionality differ substantially from frankx by now. In particular, franky provides the following new features/improvements:</p><ul>
<li><a href="#real-time-motion">Motions can be updated asynchronously.</a></li>
<li><a href="#real-time-reactions">Reactions allow for the registration of callbacks instead of just printing to stdout when fired.</a></li>
<li><a href="#robot-state">The robot state is also available during control.</a></li>
<li>A larger part of the libfranka API is exposed to python (e.g.,<code>setCollisionBehavior</code>, <code>setJoinImpedance</code>, and <code>setCartesianImpedance</code>).</li>
<li>Cartesian motion generation handles boundaries in Euler angles properly.</li>
<li><a href="#motion-types">There is a new joint motion type that supports waypoints.</a></li>
<li><a href="#geometry">The signature of <code>Affine</code> changed.</a> <code>Affine</code> does not handle elbow positions anymore. Instead, a new class <code>RobotPose</code> stores both the end-effector pose and optionally the elbow position.</li>
<li>The <code>MotionData</code> class does not exist anymore. Instead, reactions and other settings moved to <code>Motion</code>.</li>
<li><a href="#real-time-reactions">The <code>Measure</code> class allows for arithmetic operations.</a></li>
<li>Exceptions caused by libfranka are raised properly instead of being printed to stdout.</li>
<li><a href="#installation">We provide wheels for both Franka Research 3 and the older Franka Panda</a></li>
</ul>
<h2>Setup</h2>
<p>To install franky, you have to follow three steps:</p><ol type="1">
<li>Ensure that you are using a realtime kernel</li>
<li>Ensure that the executing user has permission to run real-time applications</li>
<li>Install franky via pip or build it from the sources</li>
</ol>
<h3>Installing a real-time kernel</h3>
<p>In order for franky to function properly, it requires the underlying OS to use a realtime kernel. Otherwise, you might see <code>communication_constrains_violation</code> errors.</p>
<p>To check whether your system is currently using a real-time kernel, type <code>uname -a</code>. You should see something like this: </p><div class="fragment"><div class="line">$ uname -a</div>
<div class="line">Linux [PCNAME] 5.15.0-1056-realtime #63-Ubuntu SMP PREEMPT_RT ...</div>
</div><!-- fragment --><p> If it does not say PREEMPT_RT, you are not currently running a real-time kernel.</p>
<p>There are multiple ways of installing a real-time kernel. You can <a href="https://frankaemika.github.io/docs/installation_linux.html#setting-up-the-real-time-kernel">build it from source</a> or, if you are using Ubuntu, it can be <a href="https://ubuntu.com/real-time">enabled through Ubuntu Pro</a>.</p>
<h3>Allowing the executing user to run real-time applications</h3>
<p>First, create a group <code>realtime</code> and add your user (or whoever is running franky) to this group: </p><div class="fragment"><div class="line">sudo addgroup realtime</div>
<div class="line">sudo usermod -a -G realtime $(whoami)</div>
</div><!-- fragment --><p>Afterward, add the following limits to the real-time group in /etc/security/limits.conf: </p><div class="fragment"><div class="line">@realtime soft rtprio 99</div>
<div class="line">@realtime soft priority 99</div>
<div class="line">@realtime soft memlock 102400</div>
<div class="line">@realtime hard rtprio 99</div>
<div class="line">@realtime hard priority 99</div>
<div class="line">@realtime hard memlock 102400</div>
</div><!-- fragment --><p> Log out and log in again to let the changes take effect.</p>
<p>To verify that the changes were applied, check if your user is in the <code>realtime</code> group: </p><div class="fragment"><div class="line">$ groups</div>
<div class="line">... realtime</div>
</div><!-- fragment --><p> If realtime is not listed in your groups, try rebooting.</p>
<h3>Installing franky</h3>
<p>To start using franky with Python and libfranka <em>0.13.3</em>, just install it via </p><div class="fragment"><div class="line">pip install franky-panda</div>
</div><!-- fragment --><p> We also provide wheels for libfranka versions <em>0.7.1</em>, <em>0.8.0</em>, <em>0.9.2</em>, <em>0.10.0</em>, <em>0.11.0</em>, <em>0.12.1</em>, <em>0.13.3</em>. They can be installed via </p><div class="fragment"><div class="line">VERSION=0-9-2</div>
<div class="line">wget https://github.com/TimSchneider42/franky/releases/latest/download/libfranka_${VERSION}_wheels.zip</div>
<div class="line">unzip libfranka_${VERSION}_wheels.zip</div>
<div class="line">pip install --no-index --find-links=./dist franky-panda</div>
</div><!-- fragment --><p>Franky is based on <a href="https://github.com/frankaemika/libfranka">libfranka</a>, <a href="https://eigen.tuxfamily.org">Eigen</a> for transformation calculations and <a href="https://github.com/pybind/pybind11">pybind11</a> for the Python bindings. Franky uses the <a href="https://ruckig.com">Ruckig</a> Community Version for Online Trajectory Generation (OTG). As the Franka is quite sensitive to acceleration discontinuities, it requires constrained jerk for all motions. After installing the dependencies (the exact versions can be found below), you can build and install franky via</p>
<div class="fragment"><div class="line">git clone --recurse-submodules git@github.com:timschneider42/franky.git</div>
<div class="line">cd franky</div>
<div class="line">mkdir -p build</div>
<div class="line">cd build</div>
<div class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</div>
<div class="line">make</div>
<div class="line">make install</div>
</div><!-- fragment --><p>To use franky, you can also include it as a subproject in your parent CMake via <code>add_subdirectory(franky)</code> and then <code>target_link_libraries(&lt;target&gt; libfranky)</code>. If you need only the Python module, you can install franky via</p>
<div class="fragment"><div class="line">pip install .</div>
</div><!-- fragment --><p>Make sure that the built library can be found from Python by adapting your Python Path.</p>
<h4>Using Docker</h4>
<p>To use franky within Docker we provide a <a href="docker/run/Dockerfile">Dockerfile</a> and accompanying <a href="docker-compose.yml">docker-compose</a> file.</p>
<div class="fragment"><div class="line">git clone https://github.com/timschneider42/franky.git</div>
<div class="line">cd franky/</div>
<div class="line">docker compose build franky-run</div>
</div><!-- fragment --><p>To use another version of libfranka than the default (v0.13.3) add a build argument: </p><div class="fragment"><div class="line">docker compose build franky-run --build-arg LIBFRANKA_VERSION=0.9.2</div>
</div><!-- fragment --><p>To run the container: </p><div class="fragment"><div class="line">docker compose run franky-run bash</div>
</div><!-- fragment --><p> The container requires access to the host machines network <em>and</em> elevated user rights to allow the docker user to set RT capabilities of the processes run from within it.</p>
<h4>Building franky with Docker</h4>
<p>For building franky and its wheels, we provide another Docker container that can also be launched using docker-compose:</p>
<div class="fragment"><div class="line">docker compose build franky-build</div>
<div class="line">docker compose run --rm franky-build run-tests  # To run the tests</div>
<div class="line">docker compose run --rm franky-build build-wheels  # To build wheels for all supported python versions</div>
</div><!-- fragment --><h2>Tutorial</h2>
<p>Franky comes with both a C++ and Python API that differ only regarding real-time capability. We will introduce both languages next to each other. In your C++ project, just include <code>include &lt;<a class="el" href="franky_8hpp.html">franky.hpp</a>&gt;</code> and link the library. For Python, just <code>import franky</code>. As a first example, only four lines of code are needed for simple robotic motions.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;franky.hpp&gt;</div>
<div class="line">using namespace franky;</div>
<div class="line"> </div>
<div class="line">// Connect to the robot with the FCI IP address</div>
<div class="line">Robot robot(&quot;172.16.0.2&quot;);</div>
<div class="line"> </div>
<div class="line">// Reduce velocity and acceleration of the robot</div>
<div class="line">robot.setDynamicRel(0.05);</div>
<div class="line"> </div>
<div class="line">// Move the end-effector 20cm in positive x-direction</div>
<div class="line">auto motion = CartesianMotion(RobotPose(Affine({0.2, 0.0, 0.0}), 0.0), ReferenceType::Relative);</div>
<div class="line"> </div>
<div class="line">// Finally move the robot</div>
<div class="line">robot.move(motion);</div>
</div><!-- fragment --><p>The corresponding program in Python is </p><div class="fragment"><div class="line">from franky import Affine, CartesianMotion, Robot, ReferenceType</div>
<div class="line"> </div>
<div class="line">robot = Robot(&quot;172.16.0.2&quot;)</div>
<div class="line">robot.relative_dynamics_factor = 0.05</div>
<div class="line"> </div>
<div class="line">motion = CartesianMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)</div>
<div class="line">robot.move(motion)</div>
</div><!-- fragment --><p>Furthermore, we will introduce methods for geometric calculations, for moving the robot according to different motion types, how to implement real-time reactions and changing waypoints in real time as well as controlling the gripper.</p>
<h3>Geometry</h3>
<p><code><a class="el" href="namespacefranky.html#afab9faf133666ada543b15236a8c4b5f">franky.Affine</a></code> is a python wrapper for <a href="https://eigen.tuxfamily.org/dox/group__TutorialGeometry.html">Eigen::Affine3d</a>. It is used for Cartesian poses, frames and transformation. franky adds its own constructor, which takes a position and a quaternion as inputs: </p><div class="fragment"><div class="line">import math</div>
<div class="line">from scipy.spatial.transform import Rotation</div>
<div class="line">from franky import Affine</div>
<div class="line"> </div>
<div class="line">z_translation = Affine([0.0, 0.0, 0.5])</div>
<div class="line"> </div>
<div class="line">quat = Rotation.from_euler(&quot;xyz&quot;, [0, 0, math.pi / 2]).as_quat()</div>
<div class="line">z_rotation = Affine([0.0, 0.0, 0.0], quat)</div>
<div class="line"> </div>
<div class="line">combined_transformation = z_translation * z_rotation</div>
</div><!-- fragment --><p>In all cases, distances are in [m] and rotations in [rad].</p>
<h3>Robot</h3>
<p>We wrapped most of the libfanka API (including the RobotState or ErrorMessage) for Python. Moreover, we added methods to adapt the dynamics of the robot for all motions. The <code>rel</code> name denotes that this a factor of the maximum constraints of the robot. </p><div class="fragment"><div class="line">from franky import Robot</div>
<div class="line"> </div>
<div class="line">robot = Robot(&quot;172.16.0.2&quot;)</div>
<div class="line"> </div>
<div class="line"># Recover from errors</div>
<div class="line">robot.recover_from_errors()</div>
<div class="line"> </div>
<div class="line"># Set velocity, acceleration and jerk to 5% of the maximum</div>
<div class="line">robot.relative_dynamics_factor = 0.05</div>
<div class="line"> </div>
<div class="line"># Alternatively, you can define each constraint individually</div>
<div class="line">robot.velocity_rel = 0.2</div>
<div class="line">robot.acceleration_rel = 0.1</div>
<div class="line">robot.jerk_rel = 0.01</div>
<div class="line"> </div>
<div class="line"># Get the current pose</div>
<div class="line">current_pose = robot.current_pose</div>
</div><!-- fragment --><h3>Robot State</h3>
<p>The robot state can be retrieved by calling the following methods:</p>
<ul>
<li><code>state</code>: Object of type <code>franky.RobotState</code>, which is a wrapper of the libfranka <a href="https://frankaemika.github.io/libfranka/structfranka_1_1RobotState.html">franka::RobotState</a> structure.</li>
<li><code>current_cartesian_state</code>: Object of type <code><a class="el" href="classfranky_1_1_cartesian_state.html">franky.CartesianState</a></code>, which contains the end-effector pose and velocity obtained from <a href="https://frankaemika.github.io/libfranka/structfranka_1_1RobotState.html#a193781d47722b32925e0ea7ac415f442">franka::RobotState::O_T_EE</a> and <a href="https://frankaemika.github.io/libfranka/structfranka_1_1RobotState.html#a4be112bd1a9a7d777a67aea4a18a8dcc">franka::RobotState::O_dP_EE_c</a>.</li>
<li><code>current_joint_position</code>: Object of type <code><a class="el" href="classfranky_1_1_joint_state.html" title="Joint state of a robot.">franky.JointState</a></code>, which contains the joint positions and velocities obtained from <a href="https://frankaemika.github.io/libfranka/structfranka_1_1RobotState.html#ade3335d1ac2f6c44741a916d565f7091">franka::RobotState::q</a> and <a href="https://frankaemika.github.io/libfranka/structfranka_1_1RobotState.html#a706045af1b176049e9e56df755325bd2">franka::RobotState::dq</a>.</li>
</ul>
<div class="fragment"><div class="line">robot = Robot(&quot;172.16.0.2&quot;)</div>
<div class="line"> </div>
<div class="line"># Get the current state as raw `franky.RobotState`</div>
<div class="line">state = robot.state</div>
<div class="line"> </div>
<div class="line"># Get the robot&#39;s cartesian state</div>
<div class="line">cartesian_state = robot.current_cartesian_state</div>
<div class="line">robot_pose = cartesian_state.pose  # Contains end-effector pose and elbow position</div>
<div class="line">ee_pose = robot_pose.end_effector_pose</div>
<div class="line">elbow_pos = robot_pose.elbow_position</div>
<div class="line">robot_velocity = cartesian_state.velocity  # Contains end-effector twist and elbow velocity</div>
<div class="line">ee_twist = robot_velocity.end_effector_twist</div>
<div class="line">elbow_vel = robot_velocity.elbow_velocity</div>
<div class="line"> </div>
<div class="line"># Get the robot&#39;s joint state</div>
<div class="line">joint_state = robot.current_joint_state</div>
<div class="line">joint_pos = joint_state.position</div>
<div class="line">joint_vel = joint_state.velocity</div>
</div><!-- fragment --><h3>Motion Types</h3>
<p>Franky defines a number of different motion types. In python, you can use them as follows: </p><div class="fragment"><div class="line">import math</div>
<div class="line">from scipy.spatial.transform import Rotation</div>
<div class="line">from franky import JointWaypointMotion, JointWaypoint, JointPositionStopMotion, CartesianMotion, \</div>
<div class="line">    CartesianWaypointMotion, CartesianWaypoint, Affine, Twist, RobotPose, ReferenceType, CartesianPoseStopMotion, \</div>
<div class="line">    CartesianState, JointState</div>
<div class="line"> </div>
<div class="line"># A point-to-point motion in the joint space</div>
<div class="line">m1 = JointWaypointMotion([JointWaypoint([-0.3, 0.1, 0.3, -1.4, 0.1, 1.8, 0.7])])</div>
<div class="line"> </div>
<div class="line"># A motion in joint space with multiple waypoints</div>
<div class="line">m2 = JointWaypointMotion([</div>
<div class="line">    JointWaypoint([-0.3, 0.1, 0.3, -1.4, 0.1, 1.8, 0.7]),</div>
<div class="line">    JointWaypoint([0.0, 0.3, 0.3, -1.5, -0.2, 1.5, 0.8]),</div>
<div class="line">    JointWaypoint([0.1, 0.4, 0.3, -1.4, -0.3, 1.7, 0.9])</div>
<div class="line">])</div>
<div class="line"> </div>
<div class="line"># Intermediate waypoints also permit to specify target velocities. The default target velocity is 0, meaning that the</div>
<div class="line"># robot will stop at every waypoint.</div>
<div class="line">m3 = JointWaypointMotion([</div>
<div class="line">    JointWaypoint([-0.3, 0.1, 0.3, -1.4, 0.1, 1.8, 0.7]),</div>
<div class="line">    JointWaypoint(</div>
<div class="line">        JointState(</div>
<div class="line">            position=[0.0, 0.3, 0.3, -1.5, -0.2, 1.5, 0.8],</div>
<div class="line">            velocity=[0.1, 0.0, 0.0, 0.0, -0.0, 0.0, 0.0])),</div>
<div class="line">    JointWaypoint([0.1, 0.4, 0.3, -1.4, -0.3, 1.7, 0.9])</div>
<div class="line">])</div>
<div class="line"> </div>
<div class="line"># Stop the robot</div>
<div class="line">m4 = JointPositionStopMotion()</div>
<div class="line"> </div>
<div class="line"># A linear motion in cartesian space</div>
<div class="line">quat = Rotation.from_euler(&quot;xyz&quot;, [0, 0, math.pi / 2]).as_quat()</div>
<div class="line">m5 = CartesianMotion(Affine([0.4, -0.2, 0.3], quat))</div>
<div class="line">m6 = CartesianMotion(RobotPose(Affine([0.4, -0.2, 0.3], quat), elbow_position=0.3))  # With target elbow angle</div>
<div class="line"> </div>
<div class="line"># A linear motion in cartesian space relative to the initial position</div>
<div class="line"># (Note that this motion is relative both in position and orientation. Hence, when the robot&#39;s end-effector is oriented</div>
<div class="line"># differently, it will move in a different direction)</div>
<div class="line">m7 = CartesianMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)</div>
<div class="line"> </div>
<div class="line"># Generalization of CartesianMotion that allows for multiple waypoints</div>
<div class="line">m8 = CartesianWaypointMotion([</div>
<div class="line">    CartesianWaypoint(RobotPose(Affine([0.4, -0.2, 0.3], quat), elbow_position=0.3)),</div>
<div class="line">    # The following waypoint is relative to the prior one and 50% slower</div>
<div class="line">    CartesianWaypoint(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative, RelativeDynamicsFactor(0.5, 1.0, 1.0))</div>
<div class="line">])</div>
<div class="line"> </div>
<div class="line"># Cartesian waypoints also permit to specify target velocities</div>
<div class="line">m9 = CartesianWaypointMotion([</div>
<div class="line">    CartesianWaypoint(Affine([0.5, -0.2, 0.3], quat)),</div>
<div class="line">    CartesianWaypoint(</div>
<div class="line">        CartesianState(</div>
<div class="line">            pose=Affine([0.4, -0.1, 0.3], quat),</div>
<div class="line">            velocity=Twist([-0.01, 0.01, 0.0]))),</div>
<div class="line">    CartesianWaypoint(Affine([0.3, 0.0, 0.3], quat))</div>
<div class="line">])</div>
<div class="line"> </div>
<div class="line"># Stop the robot. The difference of JointPositionStopMotion to CartesianPoseStopMotion is that JointPositionStopMotion</div>
<div class="line"># stops the robot in joint position control mode while CartesianPoseStopMotion stops it in cartesian pose control mode.</div>
<div class="line"># The difference becomes relevant when asynchronous move commands are being sent (see below).</div>
<div class="line">m10 = CartesianPoseStopMotion()</div>
</div><!-- fragment --><p>Every motion and waypoint type allows to adapt the dynamics (velocity, acceleration and jerk) by setting the respective <code>relative_dynamics_factor</code> parameter.</p>
<p>The real robot can be moved by applying a motion to the robot using <code>move</code>: </p><div class="fragment"><div class="line">robot.move(m1)</div>
<div class="line">robot.move(m2)</div>
</div><!-- fragment --><h3>Real-Time Reactions</h3>
<p>By adding reactions to the motion data, the robot can react to unforeseen events. In the Python API, you can define conditions by using a comparison between a robot's value and a given threshold. If the threshold is exceeded, the reaction fires. </p><div class="fragment"><div class="line">from franky import CartesianMotion, Affine, ReferenceType, Measure, Reaction</div>
<div class="line"> </div>
<div class="line">motion = CartesianMotion(Affine([0.0, 0.0, 0.1]), ReferenceType.Relative)  # Move down 10cm</div>
<div class="line"> </div>
<div class="line">reaction_motion = CartesianMotion(Affine([0.0, 0.0, 0.01]), ReferenceType.Relative)  # Move up for 1cm</div>
<div class="line"> </div>
<div class="line"># Trigger reaction if the Z force is greater than 30N</div>
<div class="line">reaction = Reaction(Measure.FORCE_Z &gt; 30.0, reaction_motion)</div>
<div class="line">motion.add_reaction(reaction)</div>
<div class="line"> </div>
<div class="line">robot.move(motion)</div>
</div><!-- fragment --><p>Possible values to measure are</p><ul>
<li><code>Measure.FORCE_X,</code> <code>Measure.FORCE_Y,</code> <code>Measure.FORCE_Z</code>: Force in X, Y and Z direction</li>
<li><code>Measure.REL_TIME</code>: Time in seconds since the current motion started</li>
<li><code>Measure.ABS_TIME</code>: Time in seconds since the initial motion started</li>
</ul>
<p>The difference between <code>Measure.REL_TIME</code> and <code>Measure.ABS_TIME</code> is that <code>Measure.REL_TIME</code> is reset to zero whenever a new motion starts (either by calling <code>Robot.move</code> or as a result of a triggered <code>Reaction</code>). <code>Measure.ABS_TIME</code>, on the other hand, is only reset to zero when a motion terminates regularly without being interrupted and the robot stops moving. Hence, <code>Measure.ABS_TIME</code> measures the total time in which the robot has moved without interruption.</p>
<p><code>Measure</code> values support all classical arithmetic operations, like addition, subtraction, multiplication, division, and exponentiation (both as base and exponent). </p><div class="fragment"><div class="line">normal_force = (Measure.FORCE_X ** 2 + Measure.FORCE_Y ** 2 + Measure.FORCE_Z ** 2) ** 0.5</div>
</div><!-- fragment --><p>With arithmetic comparisons, conditions can be generated. </p><div class="fragment"><div class="line">normal_force_within_bounds = normal_force &lt; 30.0</div>
<div class="line">time_up = Measure.ABS_TIME &gt; 10.0</div>
</div><!-- fragment --><p>Conditions support negation, conjunction (and), and disjunction (or): </p><div class="fragment"><div class="line">abort = ~normal_force_within_bounds | time_up</div>
<div class="line">fast_abort = ~normal_force_within_bounds | time_up</div>
</div><!-- fragment --><p>To check whether a reaction has fired, a callback can be attached: </p><div class="fragment"><div class="line">from franky import RobotState</div>
<div class="line"> </div>
<div class="line">def reaction_callback(robot_state: RobotState, rel_time: float, abs_time: float):</div>
<div class="line">    print(f&quot;Reaction fired at {abs_time}.&quot;)</div>
<div class="line"> </div>
<div class="line">reaction.register_callback(reaction_callback)</div>
</div><!-- fragment --><p>Note that these callbacks are not executed in the control thread since they would otherwise block it. Instead, they are put in a queue and executed by another thread. While this scheme ensures that the control thread can always run, it cannot prevent that the queue grows indefinitely when the callbacks take more time to execute than it takes for new callbacks to be queued. Hence, callbacks might be executed significantly after their respective reaction has fired if they are triggered in rapid succession or take a long time to execute.</p>
<p>In C++ you can additionally use lambdas to define more complex behaviours: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto motion = CartesianMotion(RobotPose(Affine({0.0, 0.0, 0.2}), 0.0), ReferenceType::Relative);</div>
<div class="line"> </div>
<div class="line">// Stop motion if force is over 10N</div>
<div class="line">auto stop_motion = StopMotion&lt;franka::CartesianPose&gt;()</div>
<div class="line"> </div>
<div class="line">motion</div>
<div class="line">  .addReaction(</div>
<div class="line">    Reaction(</div>
<div class="line">      Measure::ForceZ() &gt; 10.0,  // [N],</div>
<div class="line">      stop_motion))</div>
<div class="line">  .addReaction(</div>
<div class="line">    Reaction(</div>
<div class="line">      Condition(</div>
<div class="line">        [](const franka::RobotState&amp; state, double rel_time, double abs_time) {</div>
<div class="line">          // Lambda condition</div>
<div class="line">          return state.current_errors.self_collision_avoidance_violation;</div>
<div class="line">        }),</div>
<div class="line">      [](const franka::RobotState&amp; state, double rel_time, double abs_time) {</div>
<div class="line">        // Lambda reaction motion generator</div>
<div class="line">        // (we are just returning a stop motion, but there could be arbitrary </div>
<div class="line">        // logic here for generating reaction motions)</div>
<div class="line">        return StopMotion&lt;franka::CartesianPose&gt;();</div>
<div class="line">      })</div>
<div class="line">    ));</div>
<div class="line"> </div>
<div class="line">robot.move(motion)</div>
</div><!-- fragment --><h3>Real-Time Motion</h3>
<p>By setting the <code>asynchronous</code> parameter of <code>Robot.move</code> to <code>True</code>, the function does not block until the motion finishes. Instead, it returns immediately and, thus, allows the main thread to set new motions asynchronously. </p><div class="fragment"><div class="line">import time</div>
<div class="line">from franky import Affine, CartesianMotion, Robot, ReferenceType</div>
<div class="line"> </div>
<div class="line">robot = Robot(&quot;172.16.0.2&quot;)</div>
<div class="line">robot.relative_dynamics_factor = 0.05</div>
<div class="line"> </div>
<div class="line">motion1 = CartesianMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)</div>
<div class="line">robot.move(motion1, asynchronous=True)</div>
<div class="line"> </div>
<div class="line">time.sleep(0.5)</div>
<div class="line">motion2 = CartesianMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)</div>
<div class="line">robot.move(motion2, asynchronous=True)</div>
</div><!-- fragment --><p>By calling <code>Robot.join_motion</code> the main thread can be synchronized with the motion thread, as it will block until the robot finishes its motion. </p><div class="fragment"><div class="line">robot.join_motion()</div>
</div><!-- fragment --><p>Note that when exceptions occur during the asynchronous execution of a motion, they will not be thrown immediately. Instead, the control thread stores the exception and terminates. The next time <code>Robot.join_motion</code> or <code>Robot.move</code> are called, they will throw the stored exception in the main thread. Hence, after an asynchronous motion has finished, make sure to call <code>Robot.join_motion</code> to ensure being notified of any exceptions that occurred during the motion.</p>
<h3>Gripper</h3>
<p>In the <code><a class="el" href="classfranky_1_1_gripper.html" title="A wrapper around the franka::Gripper class that adds asynchronous functionality.">franky::Gripper</a></code> class, the default gripper force and gripper speed can be set. Then, additionally to the libfranka commands, the following helper methods can be used:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;franky.hpp&gt;</div>
<div class="line">#include &lt;chrono&gt;</div>
<div class="line">#include &lt;future&gt;</div>
<div class="line"> </div>
<div class="line">auto gripper = franky::Gripper(&quot;172.16.0.2&quot;);</div>
<div class="line"> </div>
<div class="line">double speed = 0.02; // [m/s]</div>
<div class="line">double force = 20.0; // [N]</div>
<div class="line"> </div>
<div class="line">// Move the fingers to a specific width (5cm)</div>
<div class="line">bool success = gripper.move(0.05, speed);</div>
<div class="line"> </div>
<div class="line">// Grasp an object of unknown width</div>
<div class="line">success &amp;= gripper.grasp(0.0, speed, force, epsilon_outer=1.0);</div>
<div class="line"> </div>
<div class="line">// Get the width of the grasped object</div>
<div class="line">double width = gripper.width();</div>
<div class="line"> </div>
<div class="line">// Release the object</div>
<div class="line">gripper.open(speed);</div>
<div class="line"> </div>
<div class="line">// There are also asynchronous versions of the methods</div>
<div class="line">std::future&lt;bool&gt; success_future = gripper.moveAsync(0.05, speed);</div>
<div class="line"> </div>
<div class="line">// Wait for 1s</div>
<div class="line">if (!success_future.wait_for(std::chrono::seconds(1)) == std::future_status::ready) {</div>
<div class="line">  // Get the result</div>
<div class="line">  std::cout &lt;&lt; &quot;Success: &quot; &lt;&lt; success_future.get() &lt;&lt; std::endl;</div>
<div class="line">} else {</div>
<div class="line">  gripper.stop();</div>
<div class="line">  success_future.wait();</div>
<div class="line">  std::cout &lt;&lt; &quot;Gripper motion timed out.&quot; &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The Python API follows the c++ API closely: </p><div class="fragment"><div class="line">import franky</div>
<div class="line"> </div>
<div class="line">gripper = franky.Gripper(&quot;172.16.0.2&quot;)</div>
<div class="line"> </div>
<div class="line">speed = 0.02  # [m/s]</div>
<div class="line">force = 20.0  # [N]</div>
<div class="line"> </div>
<div class="line"># Move the fingers to a specific width (5cm)</div>
<div class="line">success = gripper.move(0.05, speed)</div>
<div class="line"> </div>
<div class="line"># Grasp an object of unknown width</div>
<div class="line">success &amp;= gripper.grasp(0.0, speed, force, epsilon_outer=1.0)</div>
<div class="line"> </div>
<div class="line"># Get the width of the grasped object</div>
<div class="line">width = gripper.width</div>
<div class="line"> </div>
<div class="line"># Release the object</div>
<div class="line">gripper.open(speed)</div>
<div class="line"> </div>
<div class="line"># There are also asynchronous versions of the methods</div>
<div class="line">success_future = gripper.move_async(0.05, speed)</div>
<div class="line"> </div>
<div class="line"># Wait for 1s</div>
<div class="line">if success_future.wait(1):</div>
<div class="line">    print(f&quot;Success: {success_future.get()}&quot;)</div>
<div class="line">else:</div>
<div class="line">    gripper.stop()</div>
<div class="line">    success_future.wait()</div>
<div class="line">    print(&quot;Gripper motion timed out.&quot;)</div>
</div><!-- fragment --><h2>Documentation</h2>
<p>An auto-generated documentation can be found at <a href="https://timschneider42.github.io/franky/">https://timschneider42.github.io/franky/</a>. Moreover, there are multiple examples for both C++ and Python in the <a href="https://github.com/TimSchneider42/franky/tree/master/examples">examples</a> directory.</p>
<h2>Development</h2>
<p>Franky is written in C++17 and Python3.7. It is currently tested against following versions</p>
<ul>
<li>Libfranka v0.7.1, v0.8.0, v0.9.2, v0.10.0, v0.11.0, v0.12.1, v0.13.3</li>
<li>Eigen v3.4.0</li>
<li>Pybind11 v2.11.1</li>
<li>Catch2 v2.13.8 (for testing only)</li>
</ul>
<h2>License</h2>
<p>For non-commercial applications, this software is licensed under the LGPL v3.0. If you want to use franky within commercial applications or under a different license, please contact us for individual agreements. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
